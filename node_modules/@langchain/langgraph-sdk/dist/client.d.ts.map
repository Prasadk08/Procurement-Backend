{"version":3,"file":"client.d.ts","names":["Assistant","AssistantGraph","AssistantSortBy","AssistantSelectField","AssistantVersion","AssistantsSearchResponse","CancelAction","Checkpoint","Config","Cron","CronSelectField","CronCreateForThreadResponse","CronCreateResponse","CronSortBy","DefaultValues","GraphSchema","Item","ListNamespaceResponse","Metadata","Run","RunSelectField","RunStatus","SearchItemsResponse","SortOrder","Subgraphs","Thread","ThreadSelectField","ThreadSortBy","ThreadState","ThreadStatus","ThreadValuesFilter","Command","CronsCreatePayload","OnConflictBehavior","RunsCreatePayload","RunsStreamPayload","RunsWaitPayload","StreamEvent","StreamMode","ThreadStreamMode","TypedAsyncGenerator","AsyncCaller","AsyncCallerParams","HeaderValue","getApiKey","RequestHook","URL","RequestInit","Promise","ClientConfig","Record","BaseClient","AbortSignal","T","Response","CronsClient","AssistantsClient","ThreadsClient","TStateType","ValuesType","Array","TUpdateType","Pick","Omit","Partial","AsyncGenerator","RunsClient","TStreamMode","TSubgraphs","TCustomEventType","StoreClient","UiClient","Client","getClientConfigHash"],"sources":["../src/client.d.ts"],"sourcesContent":["import { Assistant, AssistantGraph, AssistantSortBy, AssistantSelectField, AssistantVersion, AssistantsSearchResponse, CancelAction, Checkpoint, Config, Cron, CronSelectField, CronCreateForThreadResponse, CronCreateResponse, CronSortBy, DefaultValues, GraphSchema, Item, ListNamespaceResponse, Metadata, Run, RunSelectField, RunStatus, SearchItemsResponse, SortOrder, Subgraphs, Thread, ThreadSelectField, ThreadSortBy, ThreadState, ThreadStatus, ThreadValuesFilter } from \"./schema.js\";\nimport type { Command, CronsCreatePayload, OnConflictBehavior, RunsCreatePayload, RunsStreamPayload, RunsWaitPayload, StreamEvent } from \"./types.js\";\nimport type { StreamMode, ThreadStreamMode, TypedAsyncGenerator } from \"./types.stream.js\";\nimport { AsyncCaller, AsyncCallerParams } from \"./utils/async_caller.js\";\ntype HeaderValue = string | undefined | null;\n/**\n * Get the API key from the environment.\n * Precedence:\n *   1. explicit argument (if string)\n *   2. LANGGRAPH_API_KEY\n *   3. LANGSMITH_API_KEY\n *   4. LANGCHAIN_API_KEY\n *\n * @param apiKey - API key provided as an argument. If null, skips environment lookup. If undefined, tries environment.\n * @returns The API key if found, otherwise undefined\n */\nexport declare function getApiKey(apiKey?: string | null): string | undefined;\nexport type RequestHook = (url: URL, init: RequestInit) => Promise<RequestInit> | RequestInit;\nexport interface ClientConfig {\n    apiUrl?: string;\n    /**\n     * API key for authentication.\n     * - If a string is provided, that key will be used\n     * - If undefined (default), the key will be auto-loaded from environment variables (LANGGRAPH_API_KEY, LANGSMITH_API_KEY, or LANGCHAIN_API_KEY)\n     * - If null, no API key will be set (skips auto-loading)\n     */\n    apiKey?: string | null;\n    callerOptions?: AsyncCallerParams;\n    timeoutMs?: number;\n    defaultHeaders?: Record<string, HeaderValue>;\n    onRequest?: RequestHook;\n}\ndeclare class BaseClient {\n    protected asyncCaller: AsyncCaller;\n    protected timeoutMs: number | undefined;\n    protected apiUrl: string;\n    protected defaultHeaders: Record<string, HeaderValue>;\n    protected onRequest?: RequestHook;\n    constructor(config?: ClientConfig);\n    protected prepareFetchOptions(path: string, options?: RequestInit & {\n        json?: unknown;\n        params?: Record<string, unknown>;\n        timeoutMs?: number | null;\n        withResponse?: boolean;\n    }): [url: URL, init: RequestInit];\n    protected fetch<T>(path: string, options: RequestInit & {\n        json?: unknown;\n        params?: Record<string, unknown>;\n        timeoutMs?: number | null;\n        signal?: AbortSignal;\n        withResponse: true;\n    }): Promise<[T, Response]>;\n    protected fetch<T>(path: string, options?: RequestInit & {\n        json?: unknown;\n        params?: Record<string, unknown>;\n        timeoutMs?: number | null;\n        signal?: AbortSignal;\n        withResponse?: false;\n    }): Promise<T>;\n}\nexport declare class CronsClient extends BaseClient {\n    /**\n     *\n     * @param threadId The ID of the thread.\n     * @param assistantId Assistant ID to use for this cron job.\n     * @param payload Payload for creating a cron job.\n     * @returns The created background run.\n     */\n    createForThread(threadId: string, assistantId: string, payload?: CronsCreatePayload): Promise<CronCreateForThreadResponse>;\n    /**\n     *\n     * @param assistantId Assistant ID to use for this cron job.\n     * @param payload Payload for creating a cron job.\n     * @returns\n     */\n    create(assistantId: string, payload?: CronsCreatePayload): Promise<CronCreateResponse>;\n    /**\n     *\n     * @param cronId Cron ID of Cron job to delete.\n     */\n    delete(cronId: string): Promise<void>;\n    /**\n     *\n     * @param query Query options.\n     * @returns List of crons.\n     */\n    search(query?: {\n        assistantId?: string;\n        threadId?: string;\n        limit?: number;\n        offset?: number;\n        sortBy?: CronSortBy;\n        sortOrder?: SortOrder;\n        select?: CronSelectField[];\n    }): Promise<Cron[]>;\n    /**\n     * Count cron jobs matching filters.\n     *\n     * @param query.assistantId Assistant ID to filter by.\n     * @param query.threadId Thread ID to filter by.\n     * @returns Number of cron jobs matching the criteria.\n     */\n    count(query?: {\n        assistantId?: string;\n        threadId?: string;\n    }): Promise<number>;\n}\nexport declare class AssistantsClient extends BaseClient {\n    /**\n     * Get an assistant by ID.\n     *\n     * @param assistantId The ID of the assistant.\n     * @returns Assistant\n     */\n    get(assistantId: string): Promise<Assistant>;\n    /**\n     * Get the JSON representation of the graph assigned to a runnable\n     * @param assistantId The ID of the assistant.\n     * @param options.xray Whether to include subgraphs in the serialized graph representation. If an integer value is provided, only subgraphs with a depth less than or equal to the value will be included.\n     * @returns Serialized graph\n     */\n    getGraph(assistantId: string, options?: {\n        xray?: boolean | number;\n    }): Promise<AssistantGraph>;\n    /**\n     * Get the state and config schema of the graph assigned to a runnable\n     * @param assistantId The ID of the assistant.\n     * @returns Graph schema\n     */\n    getSchemas(assistantId: string): Promise<GraphSchema>;\n    /**\n     * Get the schemas of an assistant by ID.\n     *\n     * @param assistantId The ID of the assistant to get the schema of.\n     * @param options Additional options for getting subgraphs, such as namespace or recursion extraction.\n     * @returns The subgraphs of the assistant.\n     */\n    getSubgraphs(assistantId: string, options?: {\n        namespace?: string;\n        recurse?: boolean;\n    }): Promise<Subgraphs>;\n    /**\n     * Create a new assistant.\n     * @param payload Payload for creating an assistant.\n     * @returns The created assistant.\n     */\n    create(payload: {\n        graphId: string;\n        config?: Config;\n        context?: unknown;\n        metadata?: Metadata;\n        assistantId?: string;\n        ifExists?: OnConflictBehavior;\n        name?: string;\n        description?: string;\n    }): Promise<Assistant>;\n    /**\n     * Update an assistant.\n     * @param assistantId ID of the assistant.\n     * @param payload Payload for updating the assistant.\n     * @returns The updated assistant.\n     */\n    update(assistantId: string, payload: {\n        graphId?: string;\n        config?: Config;\n        context?: unknown;\n        metadata?: Metadata;\n        name?: string;\n        description?: string;\n    }): Promise<Assistant>;\n    /**\n     * Delete an assistant.\n     *\n     * @param assistantId ID of the assistant.\n     */\n    delete(assistantId: string): Promise<void>;\n    /**\n     * List assistants.\n     * @param query Query options.\n     * @returns List of assistants or, when includePagination is true, a mapping with the assistants and next cursor.\n     */\n    search(query: {\n        graphId?: string;\n        name?: string;\n        metadata?: Metadata;\n        limit?: number;\n        offset?: number;\n        sortBy?: AssistantSortBy;\n        sortOrder?: SortOrder;\n        select?: AssistantSelectField[];\n        includePagination: true;\n    }): Promise<AssistantsSearchResponse>;\n    search(query?: {\n        graphId?: string;\n        name?: string;\n        metadata?: Metadata;\n        limit?: number;\n        offset?: number;\n        sortBy?: AssistantSortBy;\n        sortOrder?: SortOrder;\n        select?: AssistantSelectField[];\n        includePagination?: false;\n    }): Promise<Assistant[]>;\n    /**\n     * Count assistants matching filters.\n     *\n     * @param query.metadata Metadata to filter by. Exact match for each key/value.\n     * @param query.graphId Optional graph id to filter by.\n     * @param query.name Optional name to filter by.\n     * @returns Number of assistants matching the criteria.\n     */\n    count(query?: {\n        metadata?: Metadata;\n        graphId?: string;\n        name?: string;\n    }): Promise<number>;\n    /**\n     * List all versions of an assistant.\n     *\n     * @param assistantId ID of the assistant.\n     * @returns List of assistant versions.\n     */\n    getVersions(assistantId: string, payload?: {\n        metadata?: Metadata;\n        limit?: number;\n        offset?: number;\n    }): Promise<AssistantVersion[]>;\n    /**\n     * Change the version of an assistant.\n     *\n     * @param assistantId ID of the assistant.\n     * @param version The version to change to.\n     * @returns The updated assistant.\n     */\n    setLatest(assistantId: string, version: number): Promise<Assistant>;\n}\nexport declare class ThreadsClient<TStateType = DefaultValues, TUpdateType = TStateType> extends BaseClient {\n    /**\n     * Get a thread by ID.\n     *\n     * @param threadId ID of the thread.\n     * @returns The thread.\n     */\n    get<ValuesType = TStateType>(threadId: string): Promise<Thread<ValuesType>>;\n    /**\n     * Create a new thread.\n     *\n     * @param payload Payload for creating a thread.\n     * @returns The created thread.\n     */\n    create(payload?: {\n        /**\n         * Metadata for the thread.\n         */\n        metadata?: Metadata;\n        /**\n         * ID of the thread to create.\n         *\n         * If not provided, a random UUID will be generated.\n         */\n        threadId?: string;\n        /**\n         * How to handle duplicate creation.\n         *\n         * @default \"raise\"\n         */\n        ifExists?: OnConflictBehavior;\n        /**\n         * Graph ID to associate with the thread.\n         */\n        graphId?: string;\n        /**\n         * Apply a list of supersteps when creating a thread, each containing a sequence of updates.\n         *\n         * Used for copying a thread between deployments.\n         */\n        supersteps?: Array<{\n            updates: Array<{\n                values: unknown;\n                command?: Command;\n                asNode: string;\n            }>;\n        }>;\n        /**\n         * Optional time-to-live in minutes for the thread.\n         * If a number is provided, it is treated as minutes and defaults to strategy \"delete\".\n         * You may also provide an object { ttl: number, strategy?: \"delete\" }.\n         */\n        ttl?: number | {\n            ttl: number;\n            strategy?: \"delete\";\n        };\n    }): Promise<Thread<TStateType>>;\n    /**\n     * Copy an existing thread\n     * @param threadId ID of the thread to be copied\n     * @returns Newly copied thread\n     */\n    copy(threadId: string): Promise<Thread<TStateType>>;\n    /**\n     * Update a thread.\n     *\n     * @param threadId ID of the thread.\n     * @param payload Payload for updating the thread.\n     * @returns The updated thread.\n     */\n    update(threadId: string, payload?: {\n        /**\n         * Metadata for the thread.\n         */\n        metadata?: Metadata;\n        /**\n         * Optional time-to-live in minutes for the thread.\n         * If a number is provided, it is treated as minutes and defaults to strategy \"delete\".\n         * You may also provide an object { ttl: number, strategy?: \"delete\" }.\n         */\n        ttl?: number | {\n            ttl: number;\n            strategy?: \"delete\";\n        };\n    }): Promise<Thread>;\n    /**\n     * Delete a thread.\n     *\n     * @param threadId ID of the thread.\n     */\n    delete(threadId: string): Promise<void>;\n    /**\n     * List threads\n     *\n     * @param query Query options\n     * @returns List of threads\n     */\n    search<ValuesType = TStateType>(query?: {\n        /**\n         * Metadata to filter threads by.\n         */\n        metadata?: Metadata;\n        /**\n         * Filter by specific thread IDs.\n         */\n        ids?: string[];\n        /**\n         * Maximum number of threads to return.\n         * Defaults to 10\n         */\n        limit?: number;\n        /**\n         * Offset to start from.\n         */\n        offset?: number;\n        /**\n         * Thread status to filter on.\n         */\n        status?: ThreadStatus;\n        /**\n         * Sort by.\n         */\n        sortBy?: ThreadSortBy;\n        /**\n         * Sort order.\n         * Must be one of 'asc' or 'desc'.\n         */\n        sortOrder?: SortOrder;\n        /**\n         * Array of fields to select.\n         * Elements or array must be one of 'thread_id, 'created_at', 'updated_at', 'metadata', 'config', 'context', 'status', 'values', or 'interrupts'.\n         */\n        select?: ThreadSelectField[];\n        /**\n         * Values to filter threads by.\n         */\n        values?: ThreadValuesFilter;\n    }): Promise<Thread<ValuesType>[]>;\n    /**\n     * Count threads matching filters.\n     *\n     * @param query.metadata Thread metadata to filter on.\n     * @param query.values State values to filter on.\n     * @param query.status Thread status to filter on.\n     * @returns Number of threads matching the criteria.\n     */\n    count<ValuesType = TStateType>(query?: {\n        metadata?: Metadata;\n        values?: ValuesType;\n        status?: ThreadStatus;\n    }): Promise<number>;\n    /**\n     * Get state for a thread.\n     *\n     * @param threadId ID of the thread.\n     * @returns Thread state.\n     */\n    getState<ValuesType = TStateType>(threadId: string, checkpoint?: Checkpoint | string, options?: {\n        subgraphs?: boolean;\n    }): Promise<ThreadState<ValuesType>>;\n    /**\n     * Add state to a thread.\n     *\n     * @param threadId The ID of the thread.\n     * @returns\n     */\n    updateState<ValuesType = TUpdateType>(threadId: string, options: {\n        values: ValuesType;\n        checkpoint?: Checkpoint;\n        checkpointId?: string;\n        asNode?: string;\n    }): Promise<Pick<Config, \"configurable\">>;\n    /**\n     * Patch the metadata of a thread.\n     *\n     * @param threadIdOrConfig Thread ID or config to patch the state of.\n     * @param metadata Metadata to patch the state with.\n     */\n    patchState(threadIdOrConfig: string | Config, metadata: Metadata): Promise<void>;\n    /**\n     * Get all past states for a thread.\n     *\n     * @param threadId ID of the thread.\n     * @param options Additional options.\n     * @returns List of thread states.\n     */\n    getHistory<ValuesType = TStateType>(threadId: string, options?: {\n        limit?: number;\n        before?: Config;\n        checkpoint?: Partial<Omit<Checkpoint, \"thread_id\">>;\n        metadata?: Metadata;\n    }): Promise<ThreadState<ValuesType>[]>;\n    joinStream(threadId: string, options?: {\n        lastEventId?: string;\n        streamMode?: ThreadStreamMode | ThreadStreamMode[];\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ): AsyncGenerator<{\n        id?: string;\n        event: StreamEvent;\n        data: any;\n    }>;\n}\nexport declare class RunsClient<TStateType = DefaultValues, TUpdateType = TStateType, TCustomEventType = unknown> extends BaseClient {\n    stream<TStreamMode extends StreamMode | StreamMode[] = StreamMode, TSubgraphs extends boolean = false>(threadId: null, assistantId: string, payload?: Omit<RunsStreamPayload<TStreamMode, TSubgraphs>, \"multitaskStrategy\" | \"onCompletion\">): TypedAsyncGenerator<TStreamMode, TSubgraphs, TStateType, TUpdateType, TCustomEventType>;\n    stream<TStreamMode extends StreamMode | StreamMode[] = StreamMode, TSubgraphs extends boolean = false>(threadId: string, assistantId: string, payload?: RunsStreamPayload<TStreamMode, TSubgraphs>): TypedAsyncGenerator<TStreamMode, TSubgraphs, TStateType, TUpdateType, TCustomEventType>;\n    /**\n     * Create a run.\n     *\n     * @param threadId The ID of the thread.\n     * @param assistantId Assistant ID to use for this run.\n     * @param payload Payload for creating a run.\n     * @returns The created run.\n     */\n    create(threadId: string | null, assistantId: string, payload?: RunsCreatePayload): Promise<Run>;\n    /**\n     * Create a batch of stateless background runs.\n     *\n     * @param payloads An array of payloads for creating runs.\n     * @returns An array of created runs.\n     */\n    createBatch(payloads: (RunsCreatePayload & {\n        assistantId: string;\n    })[]): Promise<Run[]>;\n    wait(threadId: null, assistantId: string, payload?: Omit<RunsWaitPayload, \"multitaskStrategy\" | \"onCompletion\">): Promise<ThreadState[\"values\"]>;\n    wait(threadId: string, assistantId: string, payload?: RunsWaitPayload): Promise<ThreadState[\"values\"]>;\n    /**\n     * List all runs for a thread.\n     *\n     * @param threadId The ID of the thread.\n     * @param options Filtering and pagination options.\n     * @returns List of runs.\n     */\n    list(threadId: string, options?: {\n        /**\n         * Maximum number of runs to return.\n         * Defaults to 10\n         */\n        limit?: number;\n        /**\n         * Offset to start from.\n         * Defaults to 0.\n         */\n        offset?: number;\n        /**\n         * Status of the run to filter by.\n         */\n        status?: RunStatus;\n        select?: RunSelectField[];\n    }): Promise<Run[]>;\n    /**\n     * Get a run by ID.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @returns The run.\n     */\n    get(threadId: string, runId: string): Promise<Run>;\n    /**\n     * Cancel a run.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @param wait Whether to block when canceling\n     * @param action Action to take when cancelling the run. Possible values are `interrupt` or `rollback`. Default is `interrupt`.\n     * @returns\n     */\n    cancel(threadId: string, runId: string, wait?: boolean, action?: CancelAction): Promise<void>;\n    /**\n     * Block until a run is done.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @returns\n     */\n    join(threadId: string, runId: string, options?: {\n        signal?: AbortSignal;\n    }): Promise<TStateType>;\n    /**\n     * Stream output from a run in real-time, until the run is done.\n     *\n     * @param threadId The ID of the thread. Can be set to `null` | `undefined` for stateless runs.\n     * @param runId The ID of the run.\n     * @param options Additional options for controlling the stream behavior:\n     *   - signal: An AbortSignal that can be used to cancel the stream request\n     *   - lastEventId: The ID of the last event received. Can be used to reconnect to a stream without losing events.\n     *   - cancelOnDisconnect: When true, automatically cancels the run if the client disconnects from the stream\n     *   - streamMode: Controls what types of events to receive from the stream (can be a single mode or array of modes)\n     *        Must be a subset of the stream modes passed when creating the run. Background runs default to having the union of all\n     *        stream modes enabled.\n     * @returns An async generator yielding stream parts.\n     */\n    joinStream(threadId: string | undefined | null, runId: string, options?: {\n        signal?: AbortSignal;\n        cancelOnDisconnect?: boolean;\n        lastEventId?: string;\n        streamMode?: StreamMode | StreamMode[];\n    } | AbortSignal\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ): AsyncGenerator<{\n        id?: string;\n        event: StreamEvent;\n        data: any;\n    }>;\n    /**\n     * Delete a run.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @returns\n     */\n    delete(threadId: string, runId: string): Promise<void>;\n}\nexport declare class StoreClient extends BaseClient {\n    /**\n     * Store or update an item.\n     *\n     * @param namespace A list of strings representing the namespace path.\n     * @param key The unique identifier for the item within the namespace.\n     * @param value A dictionary containing the item's data.\n     * @param options.index Controls search indexing - null (use defaults), false (disable), or list of field paths to index.\n     * @param options.ttl Optional time-to-live in minutes for the item, or null for no expiration.\n     * @returns Promise<void>\n     *\n     * @example\n     * ```typescript\n     * await client.store.putItem(\n     *   [\"documents\", \"user123\"],\n     *   \"item456\",\n     *   { title: \"My Document\", content: \"Hello World\" },\n     *   { ttl: 60 } // expires in 60 minutes\n     * );\n     * ```\n     */\n    putItem(namespace: string[], key: string, value: Record<string, unknown>, options?: {\n        index?: false | string[] | null;\n        ttl?: number | null;\n    }): Promise<void>;\n    /**\n     * Retrieve a single item.\n     *\n     * @param namespace A list of strings representing the namespace path.\n     * @param key The unique identifier for the item.\n     * @param options.refreshTtl Whether to refresh the TTL on this read operation. If null, uses the store's default behavior.\n     * @returns Promise<Item>\n     *\n     * @example\n     * ```typescript\n     * const item = await client.store.getItem(\n     *   [\"documents\", \"user123\"],\n     *   \"item456\",\n     *   { refreshTtl: true }\n     * );\n     * console.log(item);\n     * // {\n     * //   namespace: [\"documents\", \"user123\"],\n     * //   key: \"item456\",\n     * //   value: { title: \"My Document\", content: \"Hello World\" },\n     * //   createdAt: \"2024-07-30T12:00:00Z\",\n     * //   updatedAt: \"2024-07-30T12:00:00Z\"\n     * // }\n     * ```\n     */\n    getItem(namespace: string[], key: string, options?: {\n        refreshTtl?: boolean | null;\n    }): Promise<Item | null>;\n    /**\n     * Delete an item.\n     *\n     * @param namespace A list of strings representing the namespace path.\n     * @param key The unique identifier for the item.\n     * @returns Promise<void>\n     */\n    deleteItem(namespace: string[], key: string): Promise<void>;\n    /**\n     * Search for items within a namespace prefix.\n     *\n     * @param namespacePrefix List of strings representing the namespace prefix.\n     * @param options.filter Optional dictionary of key-value pairs to filter results.\n     * @param options.limit Maximum number of items to return (default is 10).\n     * @param options.offset Number of items to skip before returning results (default is 0).\n     * @param options.query Optional search query.\n     * @param options.refreshTtl Whether to refresh the TTL on items returned by this search. If null, uses the store's default behavior.\n     * @returns Promise<SearchItemsResponse>\n     *\n     * @example\n     * ```typescript\n     * const results = await client.store.searchItems(\n     *   [\"documents\"],\n     *   {\n     *     filter: { author: \"John Doe\" },\n     *     limit: 5,\n     *     refreshTtl: true\n     *   }\n     * );\n     * console.log(results);\n     * // {\n     * //   items: [\n     * //     {\n     * //       namespace: [\"documents\", \"user123\"],\n     * //       key: \"item789\",\n     * //       value: { title: \"Another Document\", author: \"John Doe\" },\n     * //       createdAt: \"2024-07-30T12:00:00Z\",\n     * //       updatedAt: \"2024-07-30T12:00:00Z\"\n     * //     },\n     * //     // ... additional items ...\n     * //   ]\n     * // }\n     * ```\n     */\n    searchItems(namespacePrefix: string[], options?: {\n        filter?: Record<string, unknown>;\n        limit?: number;\n        offset?: number;\n        query?: string;\n        refreshTtl?: boolean | null;\n    }): Promise<SearchItemsResponse>;\n    /**\n     * List namespaces with optional match conditions.\n     *\n     * @param options.prefix Optional list of strings representing the prefix to filter namespaces.\n     * @param options.suffix Optional list of strings representing the suffix to filter namespaces.\n     * @param options.maxDepth Optional integer specifying the maximum depth of namespaces to return.\n     * @param options.limit Maximum number of namespaces to return (default is 100).\n     * @param options.offset Number of namespaces to skip before returning results (default is 0).\n     * @returns Promise<ListNamespaceResponse>\n     */\n    listNamespaces(options?: {\n        prefix?: string[];\n        suffix?: string[];\n        maxDepth?: number;\n        limit?: number;\n        offset?: number;\n    }): Promise<ListNamespaceResponse>;\n}\ndeclare class UiClient extends BaseClient {\n    private static promiseCache;\n    private static getOrCached;\n    getComponent(assistantId: string, agentName: string): Promise<string>;\n}\nexport declare class Client<TStateType = DefaultValues, TUpdateType = TStateType, TCustomEventType = unknown> {\n    /**\n     * The client for interacting with assistants.\n     */\n    assistants: AssistantsClient;\n    /**\n     * The client for interacting with threads.\n     */\n    threads: ThreadsClient<TStateType, TUpdateType>;\n    /**\n     * The client for interacting with runs.\n     */\n    runs: RunsClient<TStateType, TUpdateType, TCustomEventType>;\n    /**\n     * The client for interacting with cron runs.\n     */\n    crons: CronsClient;\n    /**\n     * The client for interacting with the KV store.\n     */\n    store: StoreClient;\n    /**\n     * The client for interacting with the UI.\n     * @internal Used by LoadExternalComponent and the API might change in the future.\n     */\n    \"~ui\": UiClient;\n    /**\n     * @internal Used to obtain a stable key representing the client.\n     */\n    private \"~configHash\";\n    constructor(config?: ClientConfig);\n}\n/**\n * @internal Used to obtain a stable key representing the client.\n */\nexport declare function getClientConfigHash(client: Client): string | undefined;\nexport {};\n"],"mappings":"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"}